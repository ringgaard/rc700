	SUBTTL	CP/M BIOS JUMP TABLE AND BIOS EXTENTIONS
	page

;==============================================================================
;= THE FOLLOWING VARIABLES SHOULD NOT BE CHANGED AS EXTERNAL                  =
;= PROGRAMS DEPENDS ON THEIR POSITION AND VALUES                              =
;==============================================================================

	JP	BOOT
WBOTE:	JP	WBOOT
	JP	CONST
	JP	CONIN
	JP	CONOUT
	JP	LIST
	JP	PUNCH
	JP	READER
	JP	XHOME
	JP	SELD
	JP	SETT
	JP	SETS
	JP	SETD
	JP	XREAD
	JP	XWRITE
	JP	STLIST
	JP	SECTRA

	PAGE

ADRMOD:	DB	0		; ADDRESS MODE = XY
WR5A:	DB	0		;
WR5B:	DB	0		;
MTYPE:	DB	0		; MASCHINE TYPE: 0=RC700,   1=RC850
				;                2=ITT3290, 3=RC703
FD0:	DB	255		;    MAXI                MINI 96 tpi
FD1:	DB	255		; 0: SS,128 B/S,25 S/T      not used
FD2:	DB	255		; 8: DD,512 B/S,30 S/T  *DD,512 B/S,20 S/T
FD3:	DB	255		;16:*SS,128 B/S,26 S/T   DD,512 B/S,20 S/T
FD4:	DB	255		;24:*DD,2S6 B/S,26 S/T !!DD,512 B/S,30 S/T
FD5:	DB	255		;32:*WINCHESTER DISK 0,9 MB UNIT 512 B/S
FD6:	DB	255		;40:*WINCHESTER DISK 0,3 MB UNIT 512 B/S
FD7:	DB	255		;4B:*WINCHESTER DISK 1,9 MB UNIT 512 B/S
FD8:	DB	255		;56:*WINCHESTER DISK 3,9 MB UNIT 512 B/S
FD9:	DB	255		;64:*WINCHESTER DISK 7,9 MB UNIT 512 B/S
FD10:	DB	255		;255: NOT USED
FD11:	DB	255		;* MEANS THAT NO SECTOR TRANSLATION IS DONE
FD12:	DB	255		;
FD13:	DB	255		;
FDI4:	DB	255		;
FD15:	DB	255		;
BOOTD:	DB	0		; 0 =>    COLD AND WARM BOOT FROM FLOPPY DISK
				; <> 0 =>  -    -   -    -     -  HARD DISK
				; Opdate in CONFI area, copyed under runtime

	PAGE

	DS	2		; RESERVED FOR FUTURE USE
	JP	WFITR		; ENTRY USED BY FORMAT UTILITY
	JP	READS		; READER STATUS
	JP	LINSEL		; LINE SELECTION
	JP	EXIT		; EXIT ROUTINE
	JP	CLOCK		; REAL TIME CLOCK
	JP	HRDFMT		; FORMAT HARD DISK TRACK

	DS	16		; RESERVED FOR FUTURE USE

	PAGE

	DB	0,0,0		; ???

PCHSAV: DW	0		; SAVED ADDRESS OF BDOS PATCH

BOTMSG:	DB	13,10
	DB	'Disk read error - reset'
	DB	13,10,0

SIGNON:	DB	12
	DB	'RC700   56k CP/M vers.2.2   rel.2.1'
	DB	13,10,0

WMESS:	DB	12,'Waiting',0

HDERR:	DB	12,'Cannot read configuration record',13,10,0

PRMSG:	LD	A,(HL)		; PROCEDURE PRINT_MESSAGE;
	OR	A		; WHILE CHARACTER<>0 DO
	RET	Z		;   WRITECHAR(CONSOLE);
	PUSH	HL		;
	LD	C,A		;
	CALL	CONOUT		;
	POP	HL		;

	INC	HL		;
	JP	PRMSG		;

BOTERR:	LD	HL,BOTMSG	; PROCEDURE BOOT_ERROR;
	CALL	PRMSG		; BEGIN
BOPLP:	JP	BOPLP		;   PRINT_MESSAGE;
				;   WHILE TRUE DO;
				; END;

	PAGE

EXIT:	LD	A,0C3H		; PROCEDURE DEF_EXIT_ROUTINE;
	LD	(EXROUT),A	;
	LD	(EXROUT+1),HL	; DEFINE ADDRESS
	EX	DE,HL		;
	LD	(EXCNT0),HL	; DEFINE COUNT
	RET			;

CLOCK:	DI			;
	OR	A		; PROCEDURE CLOCK;
	JP	Z,CLOCK1	; BEGIN
	LD	DE,(RTC0)	;   IF A<>O THEN
	LD	HL,(RTC2)	;     READ_CLOCK
	EI			;
	RET			;   ELSE
CLOCK1:	LD	(RTC0),DE	;     SET_CLOCK;
	LD	(RTC2),HL	; END;
;	EI			;
	RET			;

	PAGE

LINSEL:	ADD	A,SIOAC		; PROCEDURE LINE_SELECT;
	LD	C,A		; BEGIN
RESLIN:	DI			; (RELEASE LINE)
	LD	A,1		; (SELECT READ REG. 1)
	OUT	(C),A		;
	IN	A,(C)		; (READ REG. 1)
	EI			;
	AND	00000001B	;
	JR	Z,RESLIN	; (LOOP END)
	LD	D,5		;   (* A: 0=TERMINAL PORT, 1=PRINTER PORT *)
	LD	A,0		;   (* B: 0=RELASE, 1=LINE A, 2=LINE B *)
	CALL	SETSIG		;   DTR:=FALSE;
	DEC	B		;   RTS:=FALSE;
	RET	M		;   IF B<>O THEN
	SLA	B		;   BEGIN
	OR	B		;     DTR:=FALSE;
	CALL	SETSIG		;     RTS:=(B=2);
	OR	80H		;     (* WAIT AT LEAST 100 NS *)
	CALL	SETSIG		;     DTR:=TRUE;
	LD	HL,2		;     (* WAIT 1-2 TIMER PERIODS *)
	CALL	WAITD		;     IF CTS THEN
	LD	A,C		;       A:=0FFH
	CP	SIOAC		;     ELSE
	LD	A,(RR0_A)	;     BEGIN
	JP	Z,LINSE1	;       A:=0;
	LD	A,(RR0_B)	;       DTR:=FALSE;
LINSE1:	AND	20H		;       RTS:=FALSE;
	JP	Z,SETSIG	;     END;
	LD	A,0FFH		;   END;
	RET			; END;

SETSIG:	DI			;
	OUT	(C),D		;
	OUT	(C),A		;
	EI			;
	RET			;

PCHBDS:	XOR	A		; PERFORM TEMP PATCH TO BDOS
	LD	(PATCH1),A	;
	LD	HL,(PATCH2)	;
	LD	(PCHSAV),HL	; SAVE FOR LATER RESTORE BY PCHFIX
	LD	HL,PCHFIX	;
	LD	(PATCH2),HL	; SAVE ADDRESS  
	RET			; RETURN PROM PROC.

PCHFIX:	PUSH	HL		; RESET DISK SYS CALLED IF WBOOT FROM HD
	LD	HL,(PCHSAV)	;  GET SAVED VALUE
	LD	(PATCH2),HL	;  INSERT IT INTO BDOS
	POP	HL		; RETURN
	RET			;

	PAGE

BOOT:	LD	SP,BUFF		; USE DMA BUFFER AS STACK
	LD	HL,SIGNON	;
	CALL	PRMSG		;
	XOR	A		; INIT. CURR. LOGGED DISK = A:
	LD	(CDISK),A	;
	LD	(WBFLAG),A	;       WARMBOOTFLAG:=0
	LD	A,(BOOTD)	;
	OR	A		; IF HARD DISK USED AND ONLINE THEN
	JP	Z,BOOT04	;
	LD	A,2		;   CURR. LOGGED DISK = 2
	LD	(CDISK),A	;
BOOT04:	XOR	A		;
	LD	(HSTACT),A	;
	LD	(ERFLAG),A	;
	LD	(HSTWRT),A	;
	IN	A,(SW1)		;
	AND	80H		;
	JP	Z,WBOOT		; IF MAXI DRIVE THEN WARM BOOT
	LD	A,(DRNO)	; ELSE
	CP	2		;   IF MAX DRIVE < 2 THEN
	JP	NC,BOOT1	;
	LD	C,1		;
	CALL	SELD		;
	CALL	XHOME		;
	LD	A,B		;
	AND	10H		;
	LD	A,0		;
	JP	NZ,BOOT1	;     IF online(drive1) THEN
	INC	A		;       max_drive_no := 1
BOOT1:	LD	(DRNO),A	;     ELSE max_drive_no := 0;

	PAGE

WBOOT:	EI			;
	LD	C,0		; SELECT DRIVE 0
	LD	A,(BOOTD)	; IF BOOTD <> 0 THEN (* => HARD DISK ONLINE *)
	OR	A		;
	JR	Z,WBOOT5	;
	LD	A,2		;    WBOOT(DISK C)
	LD	C,A		;
WBOOT5:	CALL	SELD		; ENDIF;
	XOR	A		;
	LD	(UNACNT),A	;
	LD	(IOBYTE),A	;
	LD	(DSKNO),A	;
	LD	(KEYFLG),A	; KEY_BUSY:=TRUE;
	CALL	XHOME		;
	LD	SP,BUFF		; SP:=DMA_BUFFER;
	LD	BC,CPMB		;
	CALL	SETD		; DMA_ADDRESS:=CPM_BASE;
	LD	BC,1		;
	CALL	SETT		; TRACK:=1;
	LD	BC,0		;
	CALL	SETS		; SECTOR:=0;

	PAGE

RDSEC:	PUSH	BC		; REPEAT
	CALL	XREAD		;   READ(TRACK,SECTOR);
	OR	A		;
	JP	NZ,BOTERR	;
	LD	HL,(DMAADR)	;
	LD	DE,128		;
	ADD	HL,DE		;
	LD	B,H		;
	LD	C,L		;
	CALL	SETD		;   DMA_ADDRESS:=DMA_ADDRESS + 128;
	POP	BC		;
	INC	BC		;
	CALL	SETS		;   SECTOR:=SECTOR + 1;
	LD	A,C		;
	CP	NSECTS		;
	JP	NZ,RDSEC	; UNTIL SECTOR = NSECTS;
	LD	BC,BUFF		; DMA_ADDRESS:=BUFF;
	CALL	SETD		;
	LD	A,0C3H		;
	LD	(0),A		; M(0):=OPCODE(JP);
	LD	HL,WBOTE	;
	LD	(1),HL		; M(1..2):=ADDRESS(WBOOTE);
	LD	(5),A		; M(5):=OPCODE(JP);
	LD	HL,BDOS		;
	LD	(6),HL		; M(6..7):=ADDRESS(BDOS);
	LD	A,(CDISK)	;
	AND	00001111B	; REMOVE USER BITS
	LD	C,A		; C:=CUR_DISK;
	LD	A,(BOOTD)	;
	CP	C		; IF CUR.LOG.DISK =BOOTDISK THEN OK
	JR	Z,LWBT		;
	CALL	SELD		; ELSE CHECK
	LD	A,H		;      IF READING POSSIBLE
	OR	L		;
	JR	Z,SELERR	;
	LD	BC,2		;
	CALL	SETT		;
	CALL	SETS		;
	CALL	XREAD		;
	OR	A		;
	JR	Z,LWBT		;
SELERR: LD	A,(BOOTD)	; IF BAD READ THEN CUR.LOG.DSK:=BOOTD
	LD	(CDISK),A	;

LWBT:	LD	A,(CDISK)	;
	AND	00001111B	; REMOVE USER BITS
	LD	C,A		;
	CP	2		;
	CALL	nc,PCHBDS	; PATCH BDOS if current drive on hard disk
	CALL	SELD		;
	LD	A,(CDISK)	;
	LD	C,A		;
GOCPM:	LD	HL,WBFLAG	;
	LD	A,(HL)		;
	LD	(HL),01		; IF NOT WARMBOOT THEN GOTO CCP
	OR	A		;
	JR	Z,GOCCP		;
	LD	A,(CPMB+7)	; ELSE
	OR	A		;   GET LENGTH OF CCP INPUT BUFFER
	JR	Z,GOCCP		;   IF LENGTH=0 THEN GO TO CCP
	LD	HL,CPMB+9	;   ELSE
	ADD	A,L		;      IF NOT CW_FLAG THEN
	LD	L,A		;
	LD	A,(HL)		;
	OR	A		;
	JP	Z,CCPCLR	;                        GO TO CCPCLEAR
GOCCP:	JP	CPMB		;         ELSE GOTO CCP

